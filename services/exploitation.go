package services

import (
	"fmt"

	"terminal-sh/database"
	"terminal-sh/models"

	"github.com/google/uuid"
)

// ExploitationService handles server exploitation operations using tools.
type ExploitationService struct {
	db            *database.Database
	toolService   *ToolService
	serverService *ServerService
}

// NewExploitationService creates a new ExploitationService with the provided dependencies.
func NewExploitationService(db *database.Database, toolService *ToolService, serverService *ServerService) *ExploitationService {
	return &ExploitationService{
		db:            db,
		toolService:   toolService,
		serverService: serverService,
	}
}

// ExploitServer attempts to exploit a server using a tool on a specific service.
// Returns an error if the user doesn't own the tool, the service is not vulnerable, or exploitation fails.
func (s *ExploitationService) ExploitServer(userID uuid.UUID, serverPath, toolName, serviceName string) error {
	// Check if user has the tool
	if !s.toolService.UserHasTool(userID, toolName) {
		return fmt.Errorf("tool %s not owned", toolName)
	}

	// CRITICAL: Get effective tool (with patches applied)
	tool, err := s.toolService.GetEffectiveTool(userID, toolName)
	if err != nil {
		return fmt.Errorf("tool not found: %w", err)
	}

	// Get server
	server, err := s.serverService.GetServerByPath(serverPath)
	if err != nil {
		return fmt.Errorf("server not found: %w", err)
	}

	// Find the service
	var targetService *models.Service
	for i := range server.Services {
		if server.Services[i].Name == serviceName {
			targetService = &server.Services[i]
			break
		}
	}

	if targetService == nil {
		return fmt.Errorf("service %s not found on server", serviceName)
	}

	// Check if service is vulnerable
	if !targetService.Vulnerable {
		return fmt.Errorf("service %s is not vulnerable", serviceName)
	}

	// Check if tool can exploit the vulnerabilities
	canExploit := false
	exploitedVulns := []models.Exploit{}

	for _, vuln := range targetService.Vulnerabilities {
		for _, toolExploit := range tool.Exploits {
			if toolExploit.Type == vuln.Type && toolExploit.Level >= vuln.Level {
				canExploit = true
				exploitedVulns = append(exploitedVulns, models.Exploit{
					Type:  vuln.Type,
					Level: vuln.Level,
				})
				break
			}
		}
	}

	if !canExploit {
		return fmt.Errorf("tool %s cannot exploit service %s vulnerabilities", toolName, serviceName)
	}

	// Check if already exploited
	var existing models.ExploitedServer
	if err := s.db.Where("user_id = ? AND server_path = ? AND service_name = ?", 
		userID, serverPath, serviceName).First(&existing).Error; err == nil {
		// Already exploited, update exploits list
		existing.Exploits = exploitedVulns
		if err := s.db.Save(&existing).Error; err != nil {
			return fmt.Errorf("failed to update exploitation: %w", err)
		}
		return nil
	}

	// Create new exploitation record
	exploited := &models.ExploitedServer{
		UserID:      userID,
		ServerPath:  serverPath,
		ServiceName: serviceName,
		Exploits:    exploitedVulns,
	}

	if err := s.db.Create(exploited).Error; err != nil {
		return fmt.Errorf("failed to record exploitation: %w", err)
	}

	return nil
}

// GetExploitedServers retrieves all servers exploited by a user
func (s *ExploitationService) GetExploitedServers(userID uuid.UUID) ([]models.ExploitedServer, error) {
	var exploited []models.ExploitedServer
	if err := s.db.Where("user_id = ?", userID).Find(&exploited).Error; err != nil {
		return nil, err
	}
	return exploited, nil
}

// IsServerExploited checks if a user has exploited a server
func (s *ExploitationService) IsServerExploited(userID uuid.UUID, serverPath string) bool {
	var count int64
	s.db.Model(&models.ExploitedServer{}).
		Where("user_id = ? AND server_path = ?", userID, serverPath).
		Count(&count)
	return count > 0
}

// CanSSHToServer checks if a user can SSH to a server (must be exploited)
func (s *ExploitationService) CanSSHToServer(userID uuid.UUID, serverPath string) bool {
	return s.IsServerExploited(userID, serverPath)
}

